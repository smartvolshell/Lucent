完美的片键

一般来说，完美的片键将会有下列的特征：

    所有的插入、更新以及删除将会均匀分发到集群中的所有分片中。
    所有的查询将会在集群中的所有分片中平均地分发。
    所有的操作将会只面向相关的分片：更新或者删除操作将不会发送到一个没有存储被修改数据的分片上。
    相似地，一个查询将不会被送到没有存储被查询数据的分片上。
片键考量

下面是好的片键的五个准则，它们是：

    【片键基数
    【写分布
    【读分布
    【定向读
    【读本地性

1.片键基数

你需要选择一个能够被再分到小范围的片键。如果你不这样做，MongoDB将会不得不在一个单一的数据段中放置太多文档。
当这件事情发生时，最后会在你的集群中产生“庞大的”数据段，这将影响到集群的性能以及可管理性。

考虑一个存储着一个分布式系统中多台机器日志的应用。我选择使用机器的主机名对日志集合进行分片。
这个选择意味着一个给定机器的所有日志将会存储在相同的数据段。由于我的片键是机器的主机名，我将自己限制在每台机器最多就只能有一个数据段的情况。
如果一个机器可能会生成超过64MB大小的日志，MongoDB将不能分割数据段。
一个更好的片键是一个复合片键――使用机器的主机名和一个秒级粒度的时间戳：MongoDB将可以分割数据块，并且可以在一个合适的分割点进行分割。
2.写分布

正如上面讨论的，你期望写工作量均匀分布于集群的分片中。
一个单调递增的片键（例如日期或者一个对象主键）将能够保证所有的插入进入到一个单一的分片中，因此创建一个热分片并且限制扩展写工作量的能力。
其实也有创建热分片的其它方法，但是使用一个单调递增的片键是目前在我看来最普遍的错误。

如果你的写工作量基本上都是更新，而不是插入，你也将希望保证这些工作量能够均匀地分布于各分片中。
3.读分发

同样地，你希望读工作量均匀分布于集群的分片中。你需要做的事情取决于特定应用预期的读取模式。
例如，考虑一个通过文章创建时间进行分片的博客应用：其中，你最常用的查询是“显示最新创建的前20篇文章”。
该片键将会造成插入的热分片，也会造成读取的热分片。
一个更好的片键将会是一个复合键：第一个字段是2位的月数（例如：五月是05，六月是06），后面接着是一个高粒度的字段。例如：作者id或者哈希。
这个粗糙的月前缀用于搜索最近这个月先创建的文章，而高粒度的字段提供了分割和分发数据段的必要基数。